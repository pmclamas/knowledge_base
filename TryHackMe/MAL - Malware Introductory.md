**What is the purpose of Malware Analysis?**

Not only is malware analysis a form of incident response, but it is also useful in understanding how the behaviours of variants of malware result in their respective categorisation.

When analysing malware, it is important to consider the following:

-   Point of Entry (PoE)
-   What are the indicators that malware has even been executed on a machine?
-   How does the malware perform? Does it attempt to infect other devices? Does it encrypt files or install anything like a backdoor/Remote Access Tool (RAT)?
-   Most importantly - can we ultimately prevent and/or detect further infection?

**Understanding Malware campaigns**

Despite the many variants of malware, attacks can generally be classified into two types: **Targeted** and **Mass Campaign**.

**Targeted -** In most cases, malware attacks that occur this way are created for a specific purpose against a specific target. A great example of this type of purpose could be the [DarkHotel](https://www.kaspersky.co.uk/resource-center/threats/darkhotel-malware-virus-threat-definition) malware, whom is designed to steal information such as authentication details from governments officials.

Mass campaign - can be akin to many real life examples, and is the most common type of attacks. The entire purpose of this type of Malware is to infect as many devices as possible and perform whatever it may - regardless of target.

Companies track these campaigns, known as Advanced Persistent Threats (APTs) and often report on their infection rate and indicators.

**Identifying if a malware attack has happened**

The ultimate process of a malware attack can be broken down into a few broad steps:

1.  Delivery
2.  Execution
3.  Maintaining persistence (not always the case)
4.  propagation (not always)

These steps will generate lots of data. Namely: network traffic such as communicating with hosts, file system interaction like read/writes and modification.

Malware is essentially classified based upon the behaviours it produces to perform the steps listed above. For a famous example, WannaCry performs all four of these steps.

1.  _**Delivery -**_ this could be of many methods: USB (Stuxnet), pdf attachments through “Phishing” campaigns or vulnerability enumeration.
    
2.  _**Execution -**_ Here’s the main part of how we classify Malware. What does it actually do? If it encrypts files, it’s Ransomware. If it records information like keystrokes or displays adware, we can classify it as Spyware.
    
    We only understand this stage through analysing the sample, which is why analysis is important.
    
3.  _**Maintaining persistence -**_ it wouldn’t make much sense for Malware authors to go through all the trouble of developing a piece of code that is capable of execution, just for it to execute and that’s it. Unless you have a very specific agenda.
    
4.  _**Persistence -**_ this stage is largely why Malware is so “noisy”. Malware employs many techniques. Essentially, this stage is just to make sure that the “execution” is worth its while.
    
5.  _**Propagation -**_ if you can infect one device, why not infect more whilst you’re at it? Again, this is another reason why Malware can be so noticeable. Host discovery generates a lot of network traffic.
    

_**In summary, there are two categories of fingerprints that malware may leave behind on a Host after an attack:**_

_**Host-based signatures -**_ these are generally speaking the results of execution and any persistence performed by the Malware. For example, has a file been encrypted? Has any additional software been installed? These are two of many host-based signatures that are useful to know to prevent and check against further infection.

_**Network-based signatures -**_ at an overview, this classification of signatures are the observation of any networking communication taking place during delivery, execution and propagation. For example, in Ransomware, where has the Malware contacted for Bitcoin payments? Such as in the case of Wannacry, looking for a large amount of “Samba” Protocol communication attempts is a great indication of infection due to its use of “Eternalblue”.

**Static Vs. Dynamic Analysis**

There are two categories used when analysing malware:

1.  _**Static Analysis**_
2.  _**Dynamic Analysis**_

Whilst the methods and tools used for these two categories are vastly different, they are essential in compositing an understanding of how a malware behaves.

**Static Analysis -** is used to gain a high-level abstraction of the sample. It can be fairly simple to decide if a piece of code is “malicious” or not with this method alone (but not always). At its core, this method is of the analysis of the sample at the state it presents itself as, without executing the code.

Employing the use of techniques such as signature analysis via checksums means quick, efficient (albeit extremely brief) and safe analysis of malware.

**Dynamic Analysis -** this step is a lot more involved, and is where the abstraction of the sample is largely built upon. “Dynamic Analysis” essentially involves executing the sample and observing what happens. This of course is not safe. If the sample turns out to be “Ransomware”, you’ve now lost your files. If it is capable of propagating via traversing a network, you’ve now just infected your Local Area Network.

Please note that these are extremely simplistic explanations of these techniques, there is a lot more involved.

**Discussion of provided tools & their uses**

**Connecting to the Windows analysis environment (deploy)**

**Obtaining MD5 checksums of provided files**

MD5 “checksums” are a prominent attribute in the malware community. Because there can be many variants of a family of Ransomware, these MD5 “checksums” are cryptographic “fingerprints” of the files. This allows a uniformed identification throughout the community - especially with automated Sandboxes.

For example, say you have 20 files of unknown origin, you are able to identify their genus using their MD5 sum against websites such as Virustotal, if that MD5 “checksum” has been previously analyzed.

Sure, there are common names of executables (aws.exe, netlog.exe, vlc.exe ...), but anyone can name an executable as whatever they like. Just because it says “vlc” doesn’t mean it is indeed the VLC application! This is where identifying their MD5 checksum is useful, as no matter the name - their MD5 reveals its true identity.

**Now lets see if the MD5 checksums have been analysed before**

**Identifying if the Executables are obfuscated/packed**

There are a few provided tools on this Windows instance that are capable of identifying the compiler/packer of a file. However, PeID has a huge database and is a great tool for this.

Moreover, just because a file doesn’t have the .exe extension, doesn’t mean it isn’t an actual executable! For instance, it can have the .jpg extension and still be a executable piece of code.

Essentially, files have identifying attributes within its hex - known as file headers. E.g., the hex value for an executable is always “4D 5A”. So if a file with a .jpg extension has the hex header of “4D 5A”, then it is obviously not a jpg file.

**What is Obfuscation/Packing?**

Packing is one form of obfuscation that malware Authors employ to prevent the analysis of programmes. There are both legitimate and malicious reasons as to why the Author of a program will want to prevent the decompiling of their program. For example, a legitimate reason is the protection of intellectual property.

However, malware Authors employ obfuscation techniques such as packing - whilst for the same reasons, they do so with the intent to prevent people like us reversing it to understand its behaviours and ultimately with the aims of achieving infection.

**Visualising the differences between packed & non-packed code**

**Introduction to strings**

“Strings” are essentially the ASCII/Text contents of a program...this could be anything from passwords for self-extracting zips, to bitcoin addresses in ransomware samples.

Such as that in the example above, when analysing the contents of these strings, we can sometimes paint a fairly indicative picture of the behaviours of the programme - bitcoin wallets being used in ransomware.

**Introduction to imports**

The classification of IDA Freeware is arguable as the tool can be used for both static and dynamic analysis. Without going too in-depth regarding the differences, there are two classifications of tools like IDA Freeware:

-   Disassemblers
-   Debuggers

Dissassemblers reverse the compiled code of a program from machine code to human-readable instructions (assembly). This is limited to how the program represents itself in its current state. If the contents of an executable changes during execution - “Disassemblers” will not reflect this.

Whilst Debuggers deploy the same techniques used by “Disassemblers”, “Debuggers” essentially facilitate execution of the program - where the analyser can view the changes made throughout each “step” of the program. These tools are great because a true picture of the program presents itself. However, if it is indeed malicious, you have now infected yourself.

With enough understanding, an analyser can introduce “breakpoints” at various stages of a program, where the program will execute up until a breakpoint. For example, sticking with the idea of Ransomware, an analyser can create a “breakpoint” within the application prior to the actual stage of encryption files. This facilitates an analyser to view the various changes of a program during execution (such as unpacking or connecting to a remote server such as that in a botnet) up until the point of malicious infection.